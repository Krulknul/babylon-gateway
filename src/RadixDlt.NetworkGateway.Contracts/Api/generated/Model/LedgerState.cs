/*
 * Radix Babylon Gateway API
 *
 * See https://docs.radixdlt.com/main/apis/introduction.html 
 *
 * The version of the OpenAPI document: 2.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using FileParameter = RadixDlt.NetworkGateway.Contracts.Api.Client.FileParameter;
using OpenAPIDateConverter = RadixDlt.NetworkGateway.Contracts.Api.Client.OpenAPIDateConverter;

namespace RadixDlt.NetworkGateway.Contracts.Api.Model
{
    /// <summary>
    /// The ledger state against which the response was generated. Can be used to detect if the Network Gateway is returning up-to-date information. 
    /// </summary>
    [DataContract(Name = "LedgerState")]
    public partial class LedgerState : IEquatable<LedgerState>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="LedgerState" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected LedgerState() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="LedgerState" /> class.
        /// </summary>
        /// <param name="network">The name of the network against which the request is made. (required).</param>
        /// <param name="version">The state version of the ledger. Each transaction increments the state version by 1. (required).</param>
        /// <param name="timestamp">The round timestamp of the consensus round when this transaction was committed to ledger. This is not guaranteed to be strictly increasing, as it is computed as an average across the validator set. If this is significantly behind the current timestamp, the Network Gateway is likely reporting out-dated information, or the network has stalled.  (required).</param>
        /// <param name="epoch">The epoch number of the ledger at this state version. (required).</param>
        /// <param name="round">The consensus round in the epoch that this state version was committed in. (required).</param>
        public LedgerState(string network = default(string), long version = default(long), string timestamp = default(string), long epoch = default(long), long round = default(long))
        {
            // to ensure "network" is required (not null)
            if (network == null)
            {
                throw new ArgumentNullException("network is a required property for LedgerState and cannot be null");
            }
            this.Network = network;
            this._Version = version;
            // to ensure "timestamp" is required (not null)
            if (timestamp == null)
            {
                throw new ArgumentNullException("timestamp is a required property for LedgerState and cannot be null");
            }
            this.Timestamp = timestamp;
            this.Epoch = epoch;
            this.Round = round;
        }

        /// <summary>
        /// The name of the network against which the request is made.
        /// </summary>
        /// <value>The name of the network against which the request is made.</value>
        [DataMember(Name = "network", IsRequired = true, EmitDefaultValue = true)]
        public string Network { get; set; }

        /// <summary>
        /// The state version of the ledger. Each transaction increments the state version by 1.
        /// </summary>
        /// <value>The state version of the ledger. Each transaction increments the state version by 1.</value>
        [DataMember(Name = "version", IsRequired = true, EmitDefaultValue = true)]
        public long _Version { get; set; }

        /// <summary>
        /// The round timestamp of the consensus round when this transaction was committed to ledger. This is not guaranteed to be strictly increasing, as it is computed as an average across the validator set. If this is significantly behind the current timestamp, the Network Gateway is likely reporting out-dated information, or the network has stalled. 
        /// </summary>
        /// <value>The round timestamp of the consensus round when this transaction was committed to ledger. This is not guaranteed to be strictly increasing, as it is computed as an average across the validator set. If this is significantly behind the current timestamp, the Network Gateway is likely reporting out-dated information, or the network has stalled. </value>
        [DataMember(Name = "timestamp", IsRequired = true, EmitDefaultValue = true)]
        public string Timestamp { get; set; }

        /// <summary>
        /// The epoch number of the ledger at this state version.
        /// </summary>
        /// <value>The epoch number of the ledger at this state version.</value>
        [DataMember(Name = "epoch", IsRequired = true, EmitDefaultValue = true)]
        public long Epoch { get; set; }

        /// <summary>
        /// The consensus round in the epoch that this state version was committed in.
        /// </summary>
        /// <value>The consensus round in the epoch that this state version was committed in.</value>
        [DataMember(Name = "round", IsRequired = true, EmitDefaultValue = true)]
        public long Round { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class LedgerState {\n");
            sb.Append("  Network: ").Append(Network).Append("\n");
            sb.Append("  _Version: ").Append(_Version).Append("\n");
            sb.Append("  Timestamp: ").Append(Timestamp).Append("\n");
            sb.Append("  Epoch: ").Append(Epoch).Append("\n");
            sb.Append("  Round: ").Append(Round).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as LedgerState);
        }

        /// <summary>
        /// Returns true if LedgerState instances are equal
        /// </summary>
        /// <param name="input">Instance of LedgerState to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(LedgerState input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Network == input.Network ||
                    (this.Network != null &&
                    this.Network.Equals(input.Network))
                ) && 
                (
                    this._Version == input._Version ||
                    this._Version.Equals(input._Version)
                ) && 
                (
                    this.Timestamp == input.Timestamp ||
                    (this.Timestamp != null &&
                    this.Timestamp.Equals(input.Timestamp))
                ) && 
                (
                    this.Epoch == input.Epoch ||
                    this.Epoch.Equals(input.Epoch)
                ) && 
                (
                    this.Round == input.Round ||
                    this.Round.Equals(input.Round)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Network != null)
                {
                    hashCode = (hashCode * 59) + this.Network.GetHashCode();
                }
                hashCode = (hashCode * 59) + this._Version.GetHashCode();
                if (this.Timestamp != null)
                {
                    hashCode = (hashCode * 59) + this.Timestamp.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.Epoch.GetHashCode();
                hashCode = (hashCode * 59) + this.Round.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
